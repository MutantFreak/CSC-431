{
(***

   All code between the two curly braces will be spit directly into

   the generated code file.

***)

module Lexer

open System

// Open our module which defines the token types
open Tokens

// These two modules define goo needed to use fslex
open Lexing
}

// Base regular expressions

let digit = ['0'-'9']

let whitespace = [' ' '\t' ]

let newline = ('\n' | '\r' '\n')

let alpha = (['a'-'z'] | ['A'-'Z'])

let notAlphaNumericUnderQuestion = ([^'a'-'z'] | [^'A'-'Z'] | [^'0'-'9'] | [^'_'] | [^'?'])*

rule parsetokens = parse

// ----------------------------

| whitespace { parsetokens lexbuf }

| newline { parsetokens lexbuf }

// ----------------------------

// TODO: We think we need to fix this regex to make it fail w/ error if it encounters a non-digit non-space character.
| ['-']?digit+ { INT (Int32.Parse(lexeme lexbuf)) }

| ['-']?digit+('.'digit+)?(['e''E']digit+)? { FLOAT (Double.Parse(lexeme lexbuf)) }

// Write a regular expression that matches Identifiers, which are defined as a single alphabetic character followed by zero or more 
//    alphabetic, numeric, underscore (_), and question mark (?) characters. No keyword or primitive name may be used as an id.
// Write ourFunc (in F#) that takes string, matches against known keywords such as "pi" or "e", and produces the appropriate token.
//| ^alpha+( alpha | digit | _ | \? )*   { parseIdentifier (lexeme lexbuf) }
| alpha( alpha | digit | '_' | '?' )*           {
                                                  let temp = (lexeme lexbuf)
                                                  match temp with
                                                      | "pi" -> PI
                                                      | "e" -> E
                                                      | "sin" -> SIN
                                                      | "cos" -> COS
                                                      | "tan" -> TAN
                                                      | "true" -> TRUE
                                                      | "false" -> FALSE
                                                      | "new" -> NEW
                                                      | "if" -> IF
                                                      | "else" -> ELSE
                                                      | "while" -> WHILE
                                                      | "function" -> FUNCTION
                                                      | _ -> ID (temp)
                                                }

// Regex to find strings that are in quotes. Removes the resulting quotes from the beginnign and end of the sting
// before creating a STRING with that string as its field.
| '"'(_*)'"'        {
                      let temp = (lexeme lexbuf)
                      let newTemp = String.sub temp 1 (String.length temp - 2)
                      STRING (newTemp)
                    }

// ---------------------------- 

| "+" { PLUS }

| "-" { DASH }

| "*" { ASTERISK }

| "/" { SLASH }

| "^" { CARET }

| "(" { LPAREN }

| ")" { RPAREN }

| "{" { LCURLY }

| "}" { RCURLY }

| "!" { BANG }

| ";" { SEMI }

| "." { DOT }

| "," { COMMA }

| "==" { DBLEQUAL }

| "=" { EQUAL }

| "<" { LT }

| ">" { GR }

| "<=" { LTEQ }

| ">=" { GREQ }

| "&&" { AND }

| "||" { OR }

// ----------------------------

| eof { EOF }



{
(***

   All code between the two curly braces will be spit directly into

   the generated code file.

***)

module Lexer

open System

// Open our module which defines the token types
open Tokens

// These two modules define goo needed to use fslex
open Lexing
}

// Base regular expressions

let digit = ['0'-'9']

let whitespace = [' ' '\t' ]

let newline = ('\n' | '\r' '\n')

let alpha = (['a'-'z'] | ['A'-'Z'])

rule parsetokens = parse

// ----------------------------

| whitespace { parsetokens lexbuf }

| newline { parsetokens lexbuf }

// ----------------------------

// TODO: We think we need to fix this regex to make it fail w/ error if it encounters a non-digit non-space character.
| ['-']?digit+ { INT (Int32.Parse(lexeme lexbuf)) }

| ['-']?digit+('.'digit+)?(['e''E']digit+)? { FLOAT (Double.Parse(lexeme lexbuf)) }

// Write a regular expression that matches Identifiers, which are defined as a single alphabetic character followed by zero or more 
//    alphabetic, numeric, underscore (_), and question mark (?) characters. No keyword or primitive name may be used as an id.
// Write ourFunc (in F#) that takes string, matches against known keywords such as "pi" or "e", and produces the appropriate token.
//| ^alpha+( alpha | digit | _ | \? )*   { parseIdentifier (lexeme lexbuf) }
| alpha+( alpha | digit | _ | '?' )*   { let temp = (lexeme lexbuf) 
                                   match temp with
                                       | "pi" -> PI
                                       | "e" -> E
                                       | "sin" -> SIN
                                       | "cos" -> COS
                                       | "tan" -> TAN
                                       | _ -> ID (temp)
                                 }

// ----------------------------

| "+" { PLUS }

| "-" { DASH }

| "*" { ASTERISK }

| "/" { SLASH }

| "^" { CARET }

| "(" { LPAREN }

| ")" { RPAREN }

// ----------------------------

| eof { EOF }



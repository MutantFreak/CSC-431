#light

open System

// Opens the module with our generated scanner code
open Lexer

open Tokens

let parseIdentifier theString =
    match theString with
        | "pi" -> PI
        | "e" -> E
        | "sin" -> SIN
        | "cos" -> COS
        | "tan" -> TAN
        | _ -> ID (theString)

// Given a lex buffer chew through the buffer returning a token list.
let parse lexbuf =

    let mutable keepParsing = true

    let mutable tokenList = []

    while keepParsing = true do

        // 'parsetokens' is the method generated by fslex
        let parsedToken = parsetokens lexbuf

        // Add the token to our list
        tokenList <- tokenList @ [parsedToken]
   

        if parsedToken = Tokens.EOF then
            keepParsing <- false

    tokenList
 

// Attempts to parse a block of text and prints stats to STDOUT

let tryParse text =

    let lexbuf = Lexing.from_string text
    try

        let tokens = parse lexbuf
        printfn "Success. %d tokens." (List.length tokens)
        printfn "Tokens : %A" tokens

    with e ->
        let pos = lexbuf.EndPos
        printfn "Exception Message: %s\nLex error near line %d, character %d"
                e.Message pos.Line pos.Column
 

// Code which actually executes

let welcomeMessage = @"

MegaCalc (fslex sample)

-----------------------


Example Usage:

""cos pi * 42.0""

""e ^ (-1 + cos (0.0))""

""quit""


:"


Console.Write(welcomeMessage)

let mutable inputString = Console.ReadLine()

while inputString <> "quit" do

    // Try to parse the string
    tryParse inputString

    // Get the next line
    Console.Write("\n:")

    inputString <- Console.ReadLine()

Console.WriteLine("(press any key)")

Console.ReadKey(true) |> ignore

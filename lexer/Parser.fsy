%{

open AST

%}

// The start token becomes a parser function in the compiled code:
%start start

// These are the terminal tokens of the grammar along with the types of
// the data carried by each token:
%token <int> INTTok
%token <double> DOUBLETok
%token ANDTok ORTok PLUSTok MINUSTok TIMESTok DIVTok
%token GTTok LTTok GEQTok LEQTok EQTok
%token SEMICOLONTok 
%token EOFTok

//OUR CODE
%token CARETTok DOUBLEEQTok 
%token LPARENTok RPARENTok LCURLYTok RCURLYTok
%token BANGTok DOTTok COMMATok
%token <string> IDTok 
%token TRUETok FALSETok
%token IFTok ELSETok WHILETok
%token <string> STRINGTok
%token NEWTok FUNCTIONTok VARTok

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
// JBC: note that since this gets put into the interface file, it must be fully qualified.
%type < AST.exp > start

%%

// These are the rules of the grammar along with the F# code of the 
// actions executed as rules are reduced.  In this case the actions 
// produce data using F# data construction terms.
start: Prog { $1 }

Prog:
  | Stmt SEMICOLONTok Prog                      { BeginExp ($1 :: [$3]) }
  | VARTok IDTok EQTok Expr SEMICOLONTok Prog   { LetExp ($2, $4, $6) }
  | EOFTok                                      { BeginExp [] }

Stmt:
  | Expr PLUSTok Expr                         { (PrimExp (PlusP, [$1; $3])) }
  | Expr                                      { $1 }

Expr:
  | INTTok                                { (IntExp $1) }
  | DOUBLETok                             { (DoubleExp $1) }





//  | TRUETok SEMICOLONTok Prog             { (BoolExp (true)) :: $3 }
//  | FALSETok SEMICOLONTok Prog            { (BoolExp (false)) :: $3 }





//Prog:
//  | Expr EOFTok				{ [$1] }
//
//Expr: 
//  | Expr PLUSTok Term               { (PrimExp(PlusP,[$1; $3])) }
//  | INTTok SEMICOLONTok Prog              { (IntExp $1) :: $3 }
//  | DOUBLETok SEMICOLONTok Prog              { (DoubleExp $1) :: $3 }
//  | Term                            { Term ($1) }
//
//Term:
//  | Term TIMESTok Factor              { (PrimExp (TimesP, [$1; $3])) }
//  | Term DIVTok Factor              { (PrimExp (DivP, [$1; $3])) }
//  | Factor                         { Factor ($1) }
//
//Factor:
//  | INTTok                         { IntExp ($1) }
//  | DOUBLETok                      { DoubleExp ($1) }




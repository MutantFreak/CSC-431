%{

open AST

%}

// The start token becomes a parser function in the compiled code:
%start start

// These are the terminal tokens of the grammar along with the types of
// the data carried by each token:
%token <int> INTTok
%token <double> DOUBLETok
%token ANDTok ORTok PLUSTok MINUSTok TIMESTok DIVTok
%token GTTok LTTok GEQTok LEQTok EQTok
%token SEMICOLONTok 
%token EOFTok

//OUR CODE
%token CARETTok DOUBLEEQTok 
%token LPARENTok RPARENTok LCURLYTok RCURLYTok
%token BANGTok DOTTok COMMATok
%token <string> IDTok 
%token TRUETok FALSETok
%token IFTok ELSETok WHILETok
%token <string> STRINGTok
%token NEWTok FUNCTIONTok VARTok
%token RETURNTok

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
// JBC: note that since this gets put into the interface file, it must be fully qualified.
%type < AST.exp > start

%%

// These are the rules of the grammar along with the F# code of the 
// actions executed as rules are reduced.  In this case the actions 
// produce data using F# data construction terms.
start: Prog { BeginExp ($1) }

Prog:
  | Stmt Prog                                               { $1 :: $2 }
  | EOFTok                                                  { [] }
  |                                                         { [] }
  
Stmt:
// An expression followed by a semicolon.
  | Expr SEMICOLONTok                                                                         { $1 }
// if 
  | IFTok LPARENTok Expr RPARENTok LCURLYTok Prog RCURLYTok                                   { IfExp ($3, BeginExp ($6), BeginExp ([]) ) }
// if & else
  | IFTok LPARENTok Expr RPARENTok LCURLYTok Prog RCURLYTok ELSETok LCURLYTok Prog RCURLYTok  { IfExp ($3, BeginExp ($6), BeginExp ($10) ) }
// while loops with body
  | WHILETok LPARENTok Expr RPARENTok LCURLYTok Prog RCURLYTok                                { WhileExp ($3, BeginExp ($6) ) }
// var declaration
  | VARTok IDTok EQTok Expr SEMICOLONTok Prog                                                 { LetExp ($2, $4, BeginExp ($6)) }
// var assignment
  | IDTok EQTok Expr SEMICOLONTok Prog                                                        { SetExp ($1, $3) }
// return expressions
  | RETURNTok Expr SEMICOLONTok                                                               { ReturnExp ($2) }
// field setting eg: x.y = 3
  | Expr DOTTok IDTok EQTok Expr                                                              { FieldSetExp ($1, $3, $5) }
// Function declarations, with parameters
//  | FUNCTIONTok IDTok LPARENTok Params RPARENTok LCURLYTok Prog RCURLYTok Prog                { LetrecExp ([funbinding ($2, $4, $7)], $9) }

// Expr is level7
Expr:
    //TODO: put parentheses here
  | Level7                                      { $1 }

//Params:
//  | Param Params                                { $1 :: $2 }
      // No params
//  |                                             { [] }

//Param:
//  | IDTok COMMATok                                { $1 }
//  | IDTok                                         { $1 }

Level0:
  | TRUETok                               { (BoolExp (true)) }
  | FALSETok                              { (BoolExp (false)) }
  | INTTok                                { (IntExp $1) }
  | DOUBLETok                             { (DoubleExp $1) }
  | IDTok                                 { (ID $1) }
  | STRINGTok                             { (StringExp $1) }

// TODO: Add in expr DOTTok Level0
// Consider adding another level just for Id's, so that it could be expr DOTTok IDTok
// Also consider making Expr DOTTok Level0 into Expr DOTTok IDTok
// Level0
Level1:
    | Expr DOTTok IDTok                   { FieldRefExp ($1, $3) }
    | Level0                              { $1 }

Level2:
    | BANGTok Level1                      { PrimExp (NotP, [$2]) }
    | Level1                              { $1 }

Level3:
    | Level2 TIMESTok Level2              { PrimExp (TimesP, [$1; $3]) }
    | Level2 DIVTok Level2                { PrimExp (DivP, [$1; $3]) }
    | Level2                              { $1 }

Level4:
    | Level3 PLUSTok Level3               { PrimExp (PlusP, [$1; $3]) }
    | Level3 MINUSTok Level3              { PrimExp (MinusP, [$1; $3]) }
    | Level3                              { $1 }

Level5:
    | Level4 GTTok Level4                 { PrimExp (GTP, [$1; $3]) }
    | Level4 LTTok Level4                 { PrimExp (LTP, [$1; $3]) }
    | Level4 GEQTok Level4                { PrimExp (GEqP, [$1; $3]) }
    | Level4 LEQTok Level4                { PrimExp (LEqP, [$1; $3]) }
    | Level4                              { $1 }

Level6:
    | Level5 ANDTok Level5                { PrimExp (AndP, [$1; $3]) }
    | Level5 ORTok Level5                 { PrimExp (OrP, [$1; $3]) }
    | Level5                              { $1 }

Level7:
    | Level6 DOUBLEEQTok Level6           { PrimExp (EqP, [$1; $3]) }
    | Level6                              { $1 }


// Listed below are which parts of the assignment are done, and which are not.

//‹stmt› ::= ‹expr› ;                              done
//  | ‹id› = ‹expr› ;                              done
//  | ‹expr› . ‹id› = ‹expr› ;                     done
//  | var ‹id› = ‹expr› ;                          done
//  | return ‹expr› ;                              done
//  | if ( ‹expr› ) { ‹stmt›* }                    done
//  | if ( ‹expr› ) { ‹stmt›* } else { ‹stmt›* }   done
//  | while ( ‹expr› ) { ‹stmt›* }                 done
//  | function ‹id› ( ‹paramlist› ) { ‹stmt›* }

//‹expr› ::= ‹int›                                 done
//  | ‹float›                                      done
//  | true                                         done
//  | false                                        done
//  | ‹id›                                         done
//  | ‹string›                                     done
//  | ( ‹expr› )
//  | ‹id› ( ‹arglist› )
//  | ( ‹expr› ) ( ‹arglist› )
//  | ‹expr› ‹binop› ‹expr›                        done
//  | ! ‹expr›                                     done
//  | ‹expr› . ‹id›                                done
//  | ‹expr› . ‹id› ( ‹arglist› )
//  | new ‹id› ( ‹arglist› )



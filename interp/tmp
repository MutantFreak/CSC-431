
list[5] = Z

0 1 2 3
X X X X

diff = 5 - 4 = 1

newList[1] = Z
0 1
  Z

list :: newList

0 1 2 3 4 5
X X X X   Z


Professor Clements,

We've been having some problems with what type the compiler is expecting our variables to be. This is some code we have that we use to evaluate ArraySetP


type fVal =
    BoolV of bool //works
    | IntV of int //works
    | DoubleV of double //works
    | StringV of string //works
    | VoidV //works
    | ArrayV of (fVal [])

let rec consVoid newList num =
    if (num > 0)
    then consVoid (VoidV::newList) (num-1)
    else newList

let newList = consVoid [] 3

let stuff = IntV 3::[IntV 2]


let brandNewList = newList::[[IntV 3]];;






type fVal =
    BoolV of bool //works
    | IntV of int //works
    | DoubleV of double //works
    | StringV of string //works
    | VoidV //works
    | ArrayV of (fVal [])

let testing argu =
    match argu with
        | [ArrayV valList; x : fVal] -> if (2 < 3)
                                        then 
                                        else valList


List.append [int 2] [int 3];;



type fVal =
    BoolV of bool //works
    | IntV of int //works
    | DoubleV of double //works
    | StringV of string //works
    | VoidV //works
    | ArrayV of (fVal [])

// Helper function for evalArraySet, which takes a list, and index, and an fVal, and gives back a 
// different fVal list which has the index equal to the new fVal. curPos is how many times we've recursed, starting with 0.
// newList is the list being built that will eventually be returned.
let rec evalArraySetHelper fList curPos index newVal newList =
    if (List.isEmpty fList)
    then newList
            // If we're at the position where we need to do the swap
    else if (curPos = index)
              // Then append a list with just the new value in it.
         then let brandNewList = List.append newList [newVal]
              evalArraySetHelper fList.Tail (curPos+1) index newVal brandNewList
              // Otherwise, append the head of the old to the end of the new one
         else let brandNewList = List.append newList [fList.Head]
              evalArraySetHelper fList.Tail (curPos+1) index newVal brandNewList

let list1 = [int 1; int 2; int 3; int 4]

evalArraySetHelper list1 0 2 (int 10) [];;
   



index 2 := x

0 1 2 3  -->  0 1 2   -->  0 1     -->  0        --> []
a b c d       b c d        c d          d

0        -->  0 1     -->  0 1 2   -->  0 1 2 3  --> 0 1 2 3
a             a b          a b x        a b x d      a b x d




valList.[1] := x
                                             ()
                                        else valList |> ignore
                                             ()

testing [ArrayV [IntV 2; IntV 3]; IntV 10];;


type fVal =
    IntV of int
    | ObjectV of slots

and slots = Map<string,fVal ref>

let newObj = ObjectV (Map.empty<string,fVal ref>)
match newObj with
    | ObjectV (ourSlots) -> ourSlots.Add ("testName", ref (IntV 3)) |> ignore
                            printf "\nNumber of keys in the slots: %A\n" ourSlots.Count
    | _ -> printf "FAILURE";;

let newObj2 = ObjectV (Map.empty<string,fVal ref>)
match newObj2 with
    | ObjectV (ourSlots) -> let newSlots = ourSlots.Add ("testName", ref (IntV 3))
                            printf "\nNumber of keys in the slots: %A\n" newSlots.Count
    | _ -> printf "FAILURE";;

match newObj2 with
    | ObjectV (ourSlots) -> let newSlots = ourSlots.Add ("testName", ref (IntV 3))
                            printf "\nNumber of keys in the slots: %A\n" newSlots.Count
    | _ -> printf "FAILURE";;




type exp =
    ID of string //works
    | BoolExp of bool //works
    | IntExp of int //works
    | DoubleExp of double //works
    | StringExp of string //works
    | PrimExp of (prim * exp list)
    | IfExp of (exp * exp * exp) //works
    | WhileExp of (exp * exp) //works
    | LetExp of (string * exp * exp) //works. LetExp is Variable Binding on the assignment page
    | LetrecExp of (funbinding list * exp) // Needs dummy name + switching to closure values. See "Function Bindings".
    | ReturnExp of exp // Coded, but untested. Throw an exception, and catch the exception from wherever the function was called
    | SetExp of (string * exp) //works. This is for updating a variable's value
    | BeginExp of (exp list) //works. This is a list of expressions, evaluated one at a time.
                             // The value returned is the result of evaulating the last item in the list.
    | FieldRefExp of (exp * string) // Coded, but untested. Retrieving fields of objects
    | MethodCallExp of (exp * string * exp list) // Coded, but untested. Pretty much like Application, except you pull the function out of an ObjectV first. 
                                                 // The identifier 'this' is bound to the result of evaluating the 'object' expression
    | NewExp of (exp * exp list) // Mostly coded, but untested. Consists of a function expression and 0 or more argument expressions. First evaluate the exp, if it 
                                 // is not a closure, error. // If it is a closure create a new object with one slot, and bind the name 'constructor' to the 
                                 // closure. Then call the closure as described in Application, except there is one additional binding: the identifier 'this' 
                                 // is bound to the newly created object.
    | AppExp of (exp * exp list) // Coded, but untested. See Application. Evaluate the exp, if it is not a closure, error.
                                 // If it is a closure, evaluate the arguments list and put them into the closure's environment.
                                 // Then evaluate the body of the closure using the closure's newly updated environment.
    with override self.ToString () = (sprintf "%A" self)

and funbinding = int * int * int //Name of the function, its arguments, and its body exp.

and prim =
    AndP | OrP | NotP //works
    | TimesP | DivP | PlusP | MinusP | SqrtP //works
    | GTP | GEqP | LTP | LEqP //works
    | StringLengthP | StringAppendP | SubstringP | StringEqP | StringLTP //works
    | EqP //works
    | InstanceOfP // Coded, but untested.
    | IsIntP | IsBoolP | IsDoubleP | IsVoidP | IsStringP | IsClosureP | IsArrayP | IsObjectP //works
    | PrintP | ReadLineP //works
    | NewArrayP | ArrayRefP | ArraySetP | ArrayMaxP
    with override self.ToString () = (sprintf "%A" self)

type fVal =
    BoolV of bool //works
    | IntV of int //works
    | DoubleV of double //works
    | StringV of string //works
    | ClosureV of (string list * exp * env)
    | ObjectV of slots
    | VoidV //works
    | ArrayV of (fVal [])

and slots = Map<string,fVal ref>

and env = Map<string,fVal ref>

(*
let rec letrecExpHelper env (funBindingList : funbinding list) =
       // If we're out of function bindings, then we're done, so return the built up environment
    if (List.isEmpty funBindingList)
    then env
    else match funBindingList.Head with
                               //Name of the function, its arguments, and its body exp.
             | funbinding (funName, paramsList, bodyExp) -> let newEnv = env.Add (funName, VoidV)
                                                            letrecExpHelper newEnv funBindingList.Tail
             | _ -> raise (RuntimeError (sprintf "Expected funBindingList in letrecExpHelper, got: %A" theObj))
*)







type funbinding = string * string list * int

let rec myFunc env (myList : funbinding list) =
        if (List.isEmpty myList)
        then env
        else match myList.Head with
                 | (funName, paramsList, bodyExp) -> myFunc env myList.Tail;;


type fVal =
    BoolV of bool //works
    | IntV of int //works
    | DoubleV of double //works
    | StringV of string //works
    | ClosureV of (string list * exp * env)
    | ObjectV of slots
    | VoidV //works
    | ArrayV of (fVal [])

and env = Map<string,fVal ref>

and funbinding = string * string list * int

let rec myFunc2 (myEnv : env) (myList : funbinding list) =
        if (List.isEmpty myList)
        then myEnv
        else match myList.Head with
                 | (funName, paramsList, bodyExp) -> let newEnv = myEnv.Add (funName, ref VoidV)
                                                     myFunc2 newEnv myList.Tail;;

type fVal =
    BoolV of bool
    | IntV of int
    | DoubleV of double
    | StringV of string
    | ArrayV of ((fVal []) ref)
    | VoidV

let theArray = [|IntV 1; IntV 2; IntV 3; IntV 4|]
    // Set index 3 equal to IntV 10
    evalArraySet [ArrayV (ref theArray); IntV 3; IntV 10]


exception ReturnException of int
exception RuntimeError of string

let x = ref 2
try
   x := 3
with
   | ReturnException(retVal) -> raise (RuntimeError (sprintf "Found nexted Return statement. Breaking"))
raise (ReturnException 7)


